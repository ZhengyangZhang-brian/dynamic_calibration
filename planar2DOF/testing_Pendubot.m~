clc; clear all; close all;


path_to_urdf = 'planar_manip.urdf';


robot = Pendubot(path_to_urdf);



% --------------------------------------------------------------------
% identification in simuation

% specify a trajectory to follow by the first joint
q_ref = @(t, q0, a) q0 + a(1)*sin(t) + a(2)*sin(2*t) + a(3)*sin(3*t);

t = 0:1e-2:5;
figure
plot(t, q_ref(t, -pi/2, [1, 1, 1]))
grid on

% specify controller paramters
kp = 10;
kd = 1;

% simultion
x0 = [-pi/2, 0, 0, 0]';
x_sim = x0;
tau = [];
for i = 1:length(t)-1
    u = kp*(q_ref(t(i)) - x_sim(i,1)) + kd*x_sim(i,3);
    [t, x] = ode45(@(t,x) robot.ode(x,0.1*sin(x(1))), [t(i) t(i+1)], x_sim(
end



return

x0 = zeros(4,1);

[t, x] = ode45(@(t,x) robot.ode(x,0.1*sin(x(1))), 0:1e-2:5, x0);

% animate motion
robot.animate_motion(x(1:10:end,1:2)')

figure
plot(t, x(:,1:2))

return

% delete @Pendubot/get_M.m @Pendubot/get_n.m ...
%        @Pendubot/get_C.m @Pendubot/get_g.m

% robot.generate_rigid_body_regressor_function();
% robot.get_base_parameters();
% robot.generate_dynamics_functions();

% Start tests
test_regressor(path_to_urdf);
test_base_regressor(path_to_urdf);
test_frinction_regressor(path_to_urdf);
test_inertia_matrix(path_to_urdf);
test_gravity_torque(path_to_urdf);
test_velocity_product(path_to_urdf);


function test_regressor(path_to_urdf)
    tol = 1e-8;
    no_iter = 100;

    % Seed the random number generator based on the current time
    rng('shuffle');
        
    % Create a pendubot instance
    robot = Pendubot(path_to_urdf);
    
    % Create a robot instance using Matlab Toolbox
    rbt = importrobot(path_to_urdf);
    rbt.DataFormat = 'column';
    rbt.Gravity = [0 0 -9.81];
    
    for i = 1:no_iter
        q = -pi + 2*pi*rand(2,1);
        qd = -2*pi + 4*pi*rand(2,1);
        q2d = -4*pi + 8*pi*rand(2,1);

        Ylgr = robot.get_rigid_body_regressor(q, qd, q2d, 'standard');
        tau_regressor = Ylgr*robot.get_dynamic_parameters_from_urdf('standard');
        
        tau_matlab = inverseDynamics(rbt, q, qd, q2d);
        
        err = norm(tau_matlab - tau_regressor);
        assert(err < tol, 'Regressor matrix is not computed correctly. Check derivation');
    end
    fprintf('Standard Regressor Test -- OK!\n');
end


function test_base_regressor(path_to_urdf)
    tol = 1e-8;
    no_iter = 100;
    
    % Seed the random number generator based on the current time
    rng('shuffle');
    
    % Create a pendubot instance
    robot = Pendubot(path_to_urdf);
    
    % Create a robot instance using Matlab Toolbox
    rbt = importrobot(path_to_urdf);
    rbt.DataFormat = 'column';
    rbt.Gravity = [0 0 -9.81];
    
    for i = 1:no_iter
        q = -pi + 2*pi*rand(2,1);
        qd = -2*pi + 4*pi*rand(2,1);
        q2d = -4*pi + 8*pi*rand(2,1);

        Ylgr = robot.get_rigid_body_regressor(q, qd, q2d, 'base');
        tau_regressor = Ylgr*robot.get_dynamic_parameters_from_urdf('base');
        
        tau_matlab = inverseDynamics(rbt, q, qd, q2d);
        
        err = norm(tau_matlab - tau_regressor);
        assert(err < tol, 'Regressor matrix is not computed correctly. Check derivation');
    end
    fprintf('Base Regressor Test -- OK!\n');
end


function test_frinction_regressor(path_to_urdf)
    no_iter = 100;
    
     % Seed the random number generator based on the current time
    rng('shuffle');

    % Create a pendubot instance
    robot = Pendubot(path_to_urdf);
    
    for i = 1:no_iter
        q_dot = -2*pi + 4*pi*rand(2,1);
        F_v = diag(-5 + 10*rand(2,1));
        F_c = diag(rand(2,1));
        pi_frcn = [F_v(1,1) F_c(1,1) F_v(2,2) F_c(2,2)]';
        
        tau_frcn_1 = F_v*q_dot + F_c*sign(q_dot);
        tau_frcn_2 = robot.get_friction_regressor(q_dot, 'discontinuous')*pi_frcn;
        assert(norm(tau_frcn_1 - tau_frcn_2) == 0);
    end
    fprintf('Friction Regressor Test --OK!\n');
end


function test_inertia_matrix(path_to_urdf)
    tol = 1e-8;
    no_iter = 100;

    % Seed the random number generator based on the current time
    rng('shuffle');
        
    % Create a pendubot instance
    robot = Pendubot(path_to_urdf);
    
    % Create a robot instance using Matlab Toolbox
    rbt = importrobot(path_to_urdf);
    rbt.DataFormat = 'column';
    rbt.Gravity = [0 0 -9.81];
    
    for i = 1:no_iter
        q = -pi + 2*pi*rand(2,1);

        M = robot.get_M(q);
        
        M_matlab = massMatrix(rbt, q);
        
        err = norm(M_matlab - M);
        assert(err < tol, 'Regressor matrix is not computed correctly. Check derivation');
    end
    fprintf('Inertia Matrix Test -- OK!\n');
end


function test_gravity_torque(path_to_urdf)
    tol = 1e-8;
    no_iter = 100;

    % Seed the random number generator based on the current time
    rng('shuffle');
        
    % Create a pendubot instance
    robot = Pendubot(path_to_urdf);
    
    % Create a robot instance using Matlab Toolbox
    rbt = importrobot(path_to_urdf);
    rbt.DataFormat = 'column';
    rbt.Gravity = [0 0 -9.81];
    
    for i = 1:no_iter
        q = -pi + 2*pi*rand(2,1);
        
        g = robot.get_g(q);
        
        g_matlab = gravityTorque(rbt, q);
        
        err = norm(g_matlab - g);
        assert(err < tol, 'Regressor matrix is not computed correctly. Check derivation');
    end
    fprintf('Gravity Torque Test -- OK!\n');
end


function test_velocity_product(path_to_urdf)
    tol = 1e-8;
    no_iter = 100;

    % Seed the random number generator based on the current time
    rng('shuffle');
        
    % Create a pendubot instance
    robot = Pendubot(path_to_urdf);
    
    % Create a robot instance using Matlab Toolbox
    rbt = importrobot(path_to_urdf);
    rbt.DataFormat = 'column';
    rbt.Gravity = [0 0 -9.81];
    
    for i = 1:no_iter
        q = -pi + 2*pi*rand(2,1);
        qd = -2*pi + 4*pi*rand(2,1);

        Cqd = robot.get_C(q, qd)*qd;
        
        Cqd_matlab = velocityProduct(rbt, q, qd);
        
        err = norm(Cqd_matlab - Cqd);
        assert(err < tol, 'Regressor matrix is not computed correctly. Check derivation');
    end
    fprintf('Velocity Product Test -- OK!\n');
end

